[#section_vector_integration]
== Integrating {cheri_base_ext_name} and {cheri_default_ext_name} with the Vector Extension

The RISC-V vector (V) extension is generally orthogonal to CHERI because the
vector registers only hold integer or floating-point data. The vector registers
are not extended to hold capabilities. However, implementations must ensure
that every memory access using vector instructions is authorized by a suitable
capability, as described in xref:section_int_load_store_insns[xrefstyle=short],
when integrating the vector extension with {cheri_base_ext_name} and
{cheri_default_ext_name}.

Vector store instructions never write capabilities to memory. Also, the tag of
any capabilities read from memory using vector load instructions is
implicitly set to 0 as the data is written to a vector register regardless of
the actual value in memory of that capability.

NOTE: Vector load and store instructions must not be used to implement generic
memory copying in software, such as the `memcpy()` standard C library function,
because the vector registers do not hold capabilities, so the tags of any
copied capabilities will be set to 0 in the destination memory.

When the effective CHERI execution mode is {cheri_int_mode_name}, <<ddc>> is
implicitly used to authorize memory accesses from vector instructions. When the
mode is {cheri_cap_mode_name}, the authorizing capability for memory accesses
is supplied as an explicit *c* operand register in the vector instruction. All
vector load and store instructions cause CHERI exceptions if the authorizing
capability fails any of the following checks:

* The tag is set
* The capability is unsealed
* All bytes of accessed memory are inside the capability's bounds
    ** According to the vector extension cite:[riscv-v-spec], destination
vector elements are divided into three disjoing subsets: _prestart_, _body_
and _tail_. Only _body_ elements that are _active_, that is where the current
mask is enabled, are considered accessed and may give rise to faults if their
memory location is outside the capability's bounds.
* For loads, the read permission must be set in AP
* For stores, the write permission must be set in AP
